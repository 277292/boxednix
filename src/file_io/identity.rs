// SPDX-License-Identifier: GPL-3.0-only

use age::{
    armor::{ArmoredWriter, Format},
    cli_common::{
        self,
        file_io::{OutputFormat, OutputWriter},
        Passphrase, StdinGuard,
    },
    secrecy::ExposeSecret,
    x25519::{self},
    Encryptor, Identity, Recipient,
};
use anyhow::anyhow;
use std::{io::Write, path::Path};

use crate::Result;

// TODO: watch again later
pub fn create_identity(path: &Path, passphrase: bool) -> Result<()> {
    let identity = path.to_str().map(String::from);
    let mut output = OutputWriter::new(identity, false, OutputFormat::Text, 0o600, false)?;

    let sk = x25519::Identity::generate();
    let pk = sk.to_public();

    if passphrase {
        let encryptor = match cli_common::read_or_generate_passphrase() {
            Ok(Passphrase::Typed(passphrase)) => Encryptor::with_user_passphrase(passphrase),
            Ok(Passphrase::Generated(passphrase)) => {
                println!("autogenerated_passphrase:");
                println!("\t{}", passphrase.expose_secret());
                Encryptor::with_user_passphrase(passphrase)
            }
            Err(e) => Err(anyhow!(e))?,
        };
        let mut output =
            encryptor.wrap_output(ArmoredWriter::wrap_output(output, Format::AsciiArmor)?)?;

        write_formated_keys(&mut output, pk, sk)?;
        output.finish().and_then(|armor| armor.finish())?;
    } else {
        write_formated_keys(&mut output, pk, sk)?;
    }

    Ok(())
}

fn write_formated_keys<W>(output: &mut W, pk: x25519::Recipient, sk: x25519::Identity) -> Result<()>
where
    W: Write,
{
    writeln!(output, "# {}: {}", "public key", pk)?;
    writeln!(output, "{}", sk.to_string().expose_secret()).map_err(Into::into)
}

pub fn read_identities(identities: Vec<String>) -> Result<Vec<Box<dyn Identity>>> {
    let mut stdin_guard = StdinGuard::new(false);
    let identities = cli_common::read_identities(identities, None, &mut stdin_guard)?;
    Ok(identities)
}

pub fn read_recipients(
    recipents: Vec<String>,
    recipents_files: Vec<String>,
    identities: Vec<String>,
) -> Result<Vec<Box<dyn Recipient + Send>>> {
    let mut stdin_guard = StdinGuard::new(false);
    let recipients = cli_common::read_recipients(
        recipents,
        recipents_files,
        identities,
        None,
        &mut stdin_guard,
    )?;
    Ok(recipients)
}
